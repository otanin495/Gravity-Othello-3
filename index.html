<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gravity Othello 3</title>
<style>
body {
  font-family: Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: #f0f0f0;
  margin: 0;
  padding: 20px;
  box-sizing: border-box;
}

.game-info {
  margin-bottom: 20px;
  text-align: center;
}

.game-title {
  font-size: 32px;
  font-weight: bold;
  margin-bottom: 10px;
  color: #333;
}

.board-selection {
  text-align: center;
  margin-bottom: 30px;
}

.size-button {
  padding: 15px 30px;
  font-size: 18px;
  background-color: #2196F3;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  margin: 10px 0;
  display: block;
  width: 200px;
  margin-left: auto;
  margin-right: auto;
  transition: background-color 0.3s;
}

.size-button:hover {
  background-color: #1976D2;
}

.board-container {
  perspective: 1000px;
  margin-bottom: 20px;
  display: flex;
  justify-content: center;
  width: 100%;
}

.board {
  display: inline-grid;
  gap: 2px;
  background-color: #000000;
  padding: 10px;
  border-radius: 8px;
}

.board.size-4 {
  grid-template-columns: repeat(4, 60px);
  grid-template-rows: repeat(4, 60px);
}

.board.size-6 {
  grid-template-columns: repeat(6, 55px);
  grid-template-rows: repeat(6, 55px);
}

.board.size-8 {
  grid-template-columns: repeat(8, 50px);
  grid-template-rows: repeat(8, 50px);
}

.cell {
  background-color: #228B22;
  border-radius: 4px;
  position: relative;
  cursor: pointer;
  transition: background-color 0.3s;
}

.cell.size-4 {
  width: 60px;
  height: 60px;
}

.cell.size-6 {
  width: 55px;
  height: 55px;
}

.cell.size-8 {
  width: 50px;
  height: 50px;
}

.cell.valid-black {
  background-color: #A9A9A9;
  box-shadow: 0 0 10px rgba(169, 169, 169, 0.7);
}

.cell.valid-white {
  background-color: #90EE90;
  box-shadow: 0 0 10px rgba(144, 238, 144, 0.7);
}

.cell:hover.valid-black {
  background-color: #C0C0C0;
}

.cell:hover.valid-white {
  background-color: #98FB98;
}

.piece {
  border-radius: 50%;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  border: 2px solid #333;
  transition: all 0.2s linear;
}

.piece.size-4 {
  width: 50px;
  height: 50px;
}

.piece.size-6 {
  width: 45px;
  height: 45px;
}

.piece.size-8 {
  width: 40px;
  height: 40px;
}

.piece.black {
  background-color: #000;
}

.piece.white {
  background-color: #FFF;
}

.score-display {
  display: flex;
  justify-content: center;
  gap: 30px;
  font-size: 18px;
  margin-bottom: 15px;
}

.score-item {
  display: flex;
  align-items: center;
  gap: 8px;
}

.color-indicator {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid #333;
}

.color-indicator.black {
  background-color: #000;
}

.color-indicator.white {
  background-color: #FFF;
}

.message {
  font-size: 20px;
  margin-bottom: 15px;
  min-height: 30px;
  text-align: center;
  color: #333;
}

.game-over {
  color: #d32f2f;
  font-weight: bold;
}

.game-controls {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
  margin-bottom: 15px;
  width: 100%;
  max-width: 500px;
}

.arrow-row {
  display: flex;
  justify-content: center;
  gap: 10px;
}

.arrow-row button {
  width: 45px;
  height: 45px;
  font-size: 20px;
  padding: 0;
}

.bottom-buttons {
  display: flex;
  gap: 10px;
  margin-top: 10px;
}

button {
  padding: 10px 20px;
  font-size: 16px;
  background-color: #2196F3;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin: 5px;
  min-width: 70px;
}

button:hover {
  background-color: #1976D2;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background-color: #90CAF9;
}

.hidden {
  display: none;
}

@media (max-width: 768px) {
  body {
    padding: 10px;
  }

  .game-title {
    font-size: 24px;
  }

  .message {
    font-size: 16px;
  }

  .board.size-4 {
    grid-template-columns: repeat(4, 45px);
    grid-template-rows: repeat(4, 45px);
  }

  .board.size-6 {
    grid-template-columns: repeat(6, 42px);
    grid-template-rows: repeat(6, 42px);
  }

  .board.size-8 {
    grid-template-columns: repeat(8, 40px);
    grid-template-rows: repeat(8, 40px);
  }

  .cell.size-4 {
    width: 45px;
    height: 45px;
  }

  .cell.size-6 {
    width: 42px;
    height: 42px;
  }

  .cell.size-8 {
    width: 40px;
    height: 40px;
  }

  .piece.size-4 {
    width: 38px;
    height: 38px;
  }

  .piece.size-6 {
    width: 35px;
    height: 35px;
  }

  .piece.size-8 {
    width: 32px;
    height: 32px;
  }

  button {
    font-size: 14px;
    padding: 8px 16px;
  }

  .arrow-row button {
    width: 34px;
    height: 35px;
    font-size: 18px;
  }
}

@media (max-width: 480px) {
  .board.size-4 {
    grid-template-columns: repeat(4, 40px);
    grid-template-rows: repeat(4, 40px);
  }

  .board.size-6 {
    grid-template-columns: repeat(6, 37px);
    grid-template-rows: repeat(6, 37px);
  }

  .board.size-8 {
    grid-template-columns: repeat(8, 35px);
    grid-template-rows: repeat(8, 35px);
  }

  .cell.size-4 {
    width: 40px;
    height: 40px;
  }

  .cell.size-6 {
    width: 37px;
    height: 37px;
  }

  .cell.size-8 {
    width: 35px;
    height: 35px;
  }

  .piece.size-4 {
    width: 32px;
    height: 32px;
  }

  .piece.size-6 {
    width: 30px;
    height: 30px;
  }

  .piece.size-8 {
    width: 28px;
    height: 28px;
  }
}
</style>
</head>
<body>
  <div class="game-info">
    <div class="game-title">Gravity Othello 3</div>
  </div>

  <div id="boardSelection" class="board-selection">
    <p>盤面サイズを選択してください</p>
    <button class="size-button" onclick="startGame(4)">4×4盤</button>
    <button class="size-button" onclick="startGame(6)">6×6盤</button>
    <button class="size-button" onclick="startGame(8)">8×8盤</button>
  </div>

  <div id="gameArea" class="hidden">
    <div class="score-display">
      <div class="score-item">
        <div class="color-indicator black"></div>
        <span id="blackCount">2</span>
      </div>
      <div class="score-item">
        <div class="color-indicator white"></div>
        <span id="whiteCount">2</span>
      </div>
    </div>

    <div class="board-container">
      <div id="board" class="board"></div>
    </div>

    <div class="message" id="message"></div>

    <div class="game-controls">
      <div class="arrow-row">
        <button class="gravityBtn" data-dir="up">↑</button>
      </div>
      <div class="arrow-row">
        <button class="gravityBtn" data-dir="left">←</button>
        <button class="gravityBtn" data-dir="right">→</button>
      </div>
      <div class="arrow-row">
        <button class="gravityBtn" data-dir="down">↓</button>
      </div>
      <div class="bottom-buttons">
        <button id="resetBtn">リセット</button>
        <button id="backBtn">盤面選択に戻る</button>
      </div>
    </div>
  </div>

<script>
let SIZE = 8;
let board = [];
let current = 1;
let animating = false;
let boardHistory = [];
const boardEl = document.getElementById('board');
const blackCountEl = document.getElementById('blackCount');
const whiteCountEl = document.getElementById('whiteCount');
const messageEl = document.getElementById('message');
const gravityBtns = document.querySelectorAll('.gravityBtn');

function startGame(size) {
  SIZE = size;
  document.getElementById('boardSelection').classList.add('hidden');
  document.getElementById('gameArea').classList.remove('hidden');
  initBoard();
}

function backToSelection() {
  document.getElementById('boardSelection').classList.remove('hidden');
  document.getElementById('gameArea').classList.add('hidden');
}

function initBoard() {
  board = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
  const center = Math.floor(SIZE / 2);
  board[center-1][center-1] = -1;
  board[center-1][center] = 1;
  board[center][center-1] = 1;
  board[center][center] = -1;
  current = 1;
  boardHistory = [JSON.stringify(board)];
  messageEl.textContent = '黒の手番です';
  messageEl.classList.remove('game-over');
  setButtons(true);
  render();
}

function render() {
  boardEl.innerHTML = '';
  boardEl.className = `board size-${SIZE}`;
  const valid = getValidMoves(board, current);
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      const cell = document.createElement('div');
      cell.className = `cell size-${SIZE}`;
      if (board[r][c] !== 0) {
        const p = document.createElement('div');
        p.className = `piece size-${SIZE} ` + (board[r][c] === 1 ? 'black' : 'white');
        cell.appendChild(p);
      } else if (valid[r][c] && !animating) {
        cell.classList.add(current === 1 ? 'valid-black' : 'valid-white');
      }
      if (!animating) {
        cell.addEventListener('click', () => onCellClick(r, c));
      }
      boardEl.appendChild(cell);
    }
  }
  const counts = countPieces(board);
  blackCountEl.textContent = counts.black;
  whiteCountEl.textContent = counts.white;
}

function inBounds(r, c) {
  return r >= 0 && r < SIZE && c >= 0 && c < SIZE;
}

const DIRS = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,-1], [1,1]];

function getValidMoves(bd, player) {
  const valid = Array.from({length: SIZE}, () => Array(SIZE).fill(false));
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (bd[r][c] !== 0) continue;
      for (const [dr, dc] of DIRS) {
        let rr = r + dr, cc = c + dc, cnt = 0;
        while (inBounds(rr, cc) && bd[rr][cc] === -player) {
          rr += dr;
          cc += dc;
          cnt++;
        }
        if (cnt > 0 && inBounds(rr, cc) && bd[rr][cc] === player) {
          valid[r][c] = true;
          break;
        }
      }
    }
  }
  return valid;
}

function applyMove(r, c, player) {
  board[r][c] = player;
  for (const [dr, dc] of DIRS) {
    let rr = r + dr, cc = c + dc, toFlip = [];
    while (inBounds(rr, cc) && board[rr][cc] === -player) {
      toFlip.push([rr, cc]);
      rr += dr;
      cc += dc;
    }
    if (inBounds(rr, cc) && board[rr][cc] === player) {
      for (const [fr, fc] of toFlip) board[fr][fc] = player;
    }
  }
  render();
  messageEl.textContent = (player === 1 ? '黒' : '白') + 'が石を置いて返しました。';
}

function countPieces(bd) {
  let black = 0, white = 0;
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (bd[r][c] === 1) black++;
      else if (bd[r][c] === -1) white++;
    }
  }
  return {black, white};
}

function onCellClick(r, c) {
  if (animating) return;
  const valid = getValidMoves(board, current);
  if (!valid[r][c]) return;
  applyMove(r, c, current);

  boardHistory.push(JSON.stringify(board));
  
  endTurn();
}

function endTurn() {
  if (checkGameEnd()) {
    setButtons(false);
    return;
  }
  
  current = -current;
  
  const valid = getValidMoves(board, current);
  
  if (!valid.flat().some(v => v)) {
    messageEl.textContent = (current === 1 ? '黒' : '白') + 'は置ける場所がありません。重力をかける向きを選択してください。';
    render();
    updateGravityButtons();

    const anyGravityEnabled = Array.from(gravityBtns).some(btn => !btn.disabled);
    if (!anyGravityEnabled) {
      messageEl.textContent = (current === 1 ? '黒' : '白') + 'は置けず、重力もかけられません。スキップします。';
      setTimeout(() => {
        endTurn();
      }, 1500);
      return;
    }
  } else {
    messageEl.textContent = (current === 1 ? '黒' : '白') + 'の手番です';
    render();
  }
  
  if (checkGameEnd()) {
    setButtons(false);
    return;
  }
}

async function applyGravity(dir) {
  animating = true;
  setButtons(false);
  let moved = false;
  const delay = 50;
  while (true) {
    let stepMoved = false;
    if (dir === 'down') {
      for (let r = SIZE - 2; r >= 0; r--) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] !== 0 && board[r+1][c] === 0) {
            board[r+1][c] = board[r][c];
            board[r][c] = 0;
            stepMoved = true;
          }
        }
      }
    } else if (dir === 'up') {
      for (let r = 1; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (board[r][c] !== 0 && board[r-1][c] === 0) {
            board[r-1][c] = board[r][c];
            board[r][c] = 0;
            stepMoved = true;
          }
        }
      }
    } else if (dir === 'left') {
      for (let c = 1; c < SIZE; c++) {
        for (let r = 0; r < SIZE; r++) {
          if (board[r][c] !== 0 && board[r][c-1] === 0) {
            board[r][c-1] = board[r][c];
            board[r][c] = 0;
            stepMoved = true;
          }
        }
      }
    } else if (dir === 'right') {
      for (let c = SIZE - 2; c >= 0; c--) {
        for (let r = 0; r < SIZE; r++) {
          if (board[r][c] !== 0 && board[r][c+1] === 0) {
            board[r][c+1] = board[r][c];
            board[r][c] = 0;
            stepMoved = true;
          }
        }
      }
    }
    if (!stepMoved) break;
    moved = true;
    render();
    await new Promise(res => setTimeout(res, delay));
  }

  boardHistory.push(JSON.stringify(board));

  animating = false;

  const valid = getValidMoves(board, current);
  const canPlace = valid.flat().some(v => v);
  
  if (canPlace) {
    gravityBtns.forEach(btn => btn.disabled = true);
    document.getElementById('resetBtn').disabled = false;
    document.getElementById('backBtn').disabled = false;
    messageEl.textContent = (current === 1 ? '黒' : '白') + 'が重力をかけました。石を置いてください。';
    render();
  } else {
    messageEl.textContent = (current === 1 ? '黒' : '白') + 'が重力をかけました。';
    setButtons(true);
    if (!checkGameEnd()) {
      endTurn();
    } else {
      setButtons(false);
      document.getElementById('resetBtn').disabled = false;
      document.getElementById('backBtn').disabled = false;
    }
  }
}

function setButtons(enabled) {
  gravityBtns.forEach(btn => btn.disabled = !enabled);
  document.getElementById('resetBtn').disabled = false;
  document.getElementById('backBtn').disabled = false;
  if (enabled) updateGravityButtons();
}

function simulateGravity(bd, dir) {
  let testBoard = bd.map(r => r.slice());
  let moved = false;
  let iterations = 0;
  while (iterations < 100) {
    let stepMoved = false;
    if (dir === 'down') {
      for (let r = SIZE - 2; r >= 0; r--) {
        for (let c = 0; c < SIZE; c++) {
          if (testBoard[r][c] !== 0 && testBoard[r+1][c] === 0) {
            testBoard[r+1][c] = testBoard[r][c];
            testBoard[r][c] = 0;
            stepMoved = true;
          }
        }
      }
    } else if (dir === 'up') {
      for (let r = 1; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (testBoard[r][c] !== 0 && testBoard[r-1][c] === 0) {
            testBoard[r-1][c] = testBoard[r][c];
            testBoard[r][c] = 0;
            stepMoved = true;
          }
        }
      }
    } else if (dir === 'left') {
      for (let c = 1; c < SIZE; c++) {
        for (let r = 0; r < SIZE; r++) {
          if (testBoard[r][c] !== 0 && testBoard[r][c-1] === 0) {
            testBoard[r][c-1] = testBoard[r][c];
            testBoard[r][c] = 0;
            stepMoved = true;
          }
        }
      }
    } else if (dir === 'right') {
      for (let c = SIZE - 2; c >= 0; c--) {
        for (let r = 0; r < SIZE; r++) {
          if (testBoard[r][c] !== 0 && testBoard[r][c+1] === 0) {
            testBoard[r][c+1] = testBoard[r][c];
            testBoard[r][c] = 0;
            stepMoved = true;
          }
        }
      }
    }
    if (!stepMoved) break;
    moved = true;
    iterations++;
  }
  return {testBoard, moved};
}

function updateGravityButtons() {
  gravityBtns.forEach(btn => {
    const testDir = btn.dataset.dir;
    const {testBoard, moved} = simulateGravity(board, testDir);
    const testBoardStr = JSON.stringify(testBoard);

    if (!moved) {
      btn.disabled = true;
      return;
    }

    const isPastBoard = boardHistory.includes(testBoardStr);
    
    if (isPastBoard) {
      btn.disabled = true;
    } else {
      btn.disabled = false;
    }
  });
}

function checkGameEnd() {
  const counts = countPieces(board);
  const validBlack = getValidMoves(board, 1);
  const validWhite = getValidMoves(board, -1);
  const blackCan = validBlack.flat().some(v => v);
  const whiteCan = validWhite.flat().some(v => v);
  const filled = counts.black + counts.white === SIZE * SIZE;
  if (filled || (!blackCan && !whiteCan)) {
    let msg = '';
    if (counts.black > counts.white) {
      msg = '黒の勝ち！ (' + counts.black + ' 対 ' + counts.white + ')';
    } else if (counts.white > counts.black) {
      msg = '白の勝ち！ (' + counts.white + ' 対 ' + counts.black + ')';
    } else {
      msg = '引き分け！ (' + counts.black + ' 対 ' + counts.white + ')';
    }
    messageEl.textContent = msg;
    messageEl.classList.add('game-over');
    return true;
  }
  return false;
}

document.getElementById('resetBtn').addEventListener('click', () => {
  initBoard();
  render();
});

document.getElementById('backBtn').addEventListener('click', backToSelection);

gravityBtns.forEach(btn => btn.addEventListener('click', () => {
  if (!animating) applyGravity(btn.dataset.dir);
}));
</script>
</body>
</html>
